<!doctype html><html lang=en dir=auto><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Git 使用教程（上） | Laoluo's Blog</title>
<meta name=keywords content="Git"><meta name=description content="本文主要介绍了 Git 本地和远程的一些常用操作，包括 commit，branch，merge，rebase，fetch 和 push 等。"><meta name=author content="James"><link rel=canonical href=http://localhost:1313/git-instruction-1/><link crossorigin=anonymous href=/assets/css/stylesheet.d2540e28ae03a9ed42429ed74228412a18d4ea29c639e31e4f0b1512e252624f.css integrity="sha256-0lQOKK4Dqe1CQp7XQihBKhjU6inGOeMeTwsVEuJSYk8=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=http://localhost:1313/icons/linux.png><link rel=icon type=image/png sizes=16x16 href=http://localhost:1313/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=http://localhost:1313/favicon-32x32.png><link rel=apple-touch-icon href=http://localhost:1313/apple-touch-icon.png><link rel=mask-icon href=http://localhost:1313/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=http://localhost:1313/git-instruction-1/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/lxgw-wenkai-screen-webfont@1.7.0/style.min.css><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fontsource/cascadia-code@4.2.1/index.min.css><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><meta property="og:title" content="Git 使用教程（上）"><meta property="og:description" content="本文主要介绍了 Git 本地和远程的一些常用操作，包括 commit，branch，merge，rebase，fetch 和 push 等。"><meta property="og:type" content="article"><meta property="og:url" content="http://localhost:1313/git-instruction-1/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-10-22T21:31:32+08:00"><meta property="article:modified_time" content="2021-10-22T21:31:32+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Git 使用教程（上）"><meta name=twitter:description content="本文主要介绍了 Git 本地和远程的一些常用操作，包括 commit，branch，merge，rebase，fetch 和 push 等。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://localhost:1313/posts/"},{"@type":"ListItem","position":2,"name":"Git 使用教程（上）","item":"http://localhost:1313/git-instruction-1/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Git 使用教程（上）","name":"Git 使用教程（上）","description":"本文主要介绍了 Git 本地和远程的一些常用操作，包括 commit，branch，merge，rebase，fetch 和 push 等。\n","keywords":["Git"],"articleBody":"本文主要介绍了 Git 本地和远程的一些常用操作，包括 commit，branch，merge，rebase，fetch 和 push 等。\n基本操作 Commit Git 仓库中的提交记录保存的是你的目录下所有文件的快照。 Git 希望提交记录尽可能地轻量，因此在你每次进行提交时，它并不会盲目地复制整个目录。条件允许的情况下，它会将当前版本与仓库中的上一个版本进行对比，并把所有的差异打包到一起作为一个提交记录。 Git 还保存了提交的历史记录。\n使用方法为\ngit commit -m \"Some Message\" Branch Git 的分支也非常轻量。它们只是简单地指向某个提交纪录，仅此而已。因此即使创建再多的分支也不会造成储存或内存上的开销，并且按逻辑分解工作到不同的分支要比维护那些特别臃肿的分支简单多了。所以使用 Git 的一个原则就是早建分支，多用分支。\n创建一个新的分支\ngit branch newBranch 切换到该分支\ngit checkout newBranch 上述两条命令可以由一种更简洁的方式实现\ngit checkout -b newBranch Merge 现在我们讨论如何将两个分支合并到一起。就是说我们新建一个分支，在其上开发某个新功能，开发完成后再合并回主线。完成该操作的第一种方法是 git merge。\n例如，我们要将 bugFix 分支合并到 main 分支里，切换到 main 分支，执行\ngit merge bugFix 这样 main 分支就包含了对代码库的所有修改。\nRebase 合并分支的第二种方法是 git rebase。Rebase 实际上就是取出一系列的提交记录，“复制”它们，然后在另外一个地方逐个的放下去。Rebase 的优势就是可以创造更线性的提交历史。\n我们想要把 bugFix 分支里的工作直接移到 main 分支上。移动以后会使得两个分支的功能看起来像是按顺序开发，但实际上它们是并行开发的。注意当前所在的分支是 bugFix。\ngit rebase main 事实上，git rebase 可以添加两个参数，后面的参数默认为当前的分支。\ngit rebase 会将 topicBranch 变基到 baseBranch 上，也就是将 topicBranch 的代码“续”到了 baseBranch 后面。\n上面的命令等价于\ngit rebase main bugFix 这样，我们在进行 rebase 时就不需要频繁切换分支了。\n我们只需要记住，rebase 时修改的是后面的分支，前面的分支不动就可以了。\nMerge 和 Rebase 的选择 那么，我们在合并分支时应该什么时候使用 rebase，什么时候使用 merge 呢？\n一个基本的原则是\nsub-branches rebase on master, master merges sub-branches.\n也就是在上例中，我们如果想要将 bugFix 里的工作合并到 main 中，应当采用\ngit rebase main git checkout main git merge bugFix 远程仓库 Clone 远程仓库并不复杂, 在如今的云计算盛行的世界很容易把远程仓库想象成一个富有魔力的东西, 但实际上它们只是你的仓库在另个一台计算机上的拷贝。你可以通过因特网与这台计算机通信 —— 也就是增加或是获取提交记录。话虽如此, 远程仓库却有一系列强大的特性：\n首先也是最重要的的点, 远程仓库是一个强大的备份。本地仓库也有恢复文件到指定版本的能力, 但所有的信息都是保存在本地的。有了远程仓库以后，即使丢失了本地所有数据, 你仍可以通过远程仓库拿回你丢失的数据。 还有就是, 远程让代码社交化了! 既然你的项目被托管到别的地方了, 你的朋友可以更容易地为你的项目做贡献(或者拉取最新的变更) git clone 命令的作用是在本地创建一个远程仓库的拷贝（比如从 github.com）。\n当我们 clone 一个具有子模块的项目时，默认会包含该子模块目录，但其中还没有任何文件。我们必须运行两个命令：git submodule init 用来初始化本地配置文件，而 git submodule update 则从该项目中抓取所有数据并检出父项目中列出的合适的提交。\n不过，还有一种更简单的方式，如果给 git clone 命令传递 --recurse-submodules 选项，它就会自动初始化并更新仓库中的每一个子模块， 包括可能存在的嵌套子模块。\nFetch \u0026 Pull git fetch 用于从远程仓库中获取数据。\ngit fetch 完成了仅有的但是很重要的两步:\n从远程仓库下载本地仓库中缺失的提交记录 更新远程分支指针(如 origin/main) git fetch 实际上将本地仓库中的远程分支更新成了远程仓库相应分支最新的状态。\n而 git fetch 并不会改变你本地仓库的状态。它不会更新你的 main 分支，也不会修改你磁盘上的文件。\n因此，我们需要执行通过以下命令来将这些变化更新到我们的工作当中。\ngit cherry-pick origin/main git rebase origin/main git merge origin/main 实际上，由于先抓取更新再合并到本地分支这个流程很常用，因此 Git 提供了一个专门的命令来完成这两个操作。它就是我们要讲的 git pull。git pull 相当于 git fetch 和 git merge 两个操作。\n例如\ngit fetch git merge origin/main 和\ngit pull 完全等价。\nPush git push 负责将你的变更上传到指定的远程仓库，并在远程仓库上合并你的新提交记录。一旦 git push 完成, 你的朋友们就可以从这个远程仓库下载你分享的成果了！\n但是，当历史偏离时 git push 会失败。比如你最新提交的 C3 基于远程分支中的 C1。而远程仓库中该分支已经更新到 C2 了，所以 Git 拒绝了你的推送请求。实际上它会强制你先合并远程最新的代码，然后才能分享你的工作。\n那该如何解决这个问题呢？很简单，你需要做的就是使你的工作基于最新的远程分支。有许多方法可以做到这一点，不过最直接的方法就是通过 rebase 调整你的工作。\n我们可以在 push 之前做 rebase\ngit fetch git rebase origin/main git push 当然，也可以使用 merge。尽管 git merge 不会移动你的工作（它会创建新的合并提交），但是它会告诉 Git 你已经合并了远程仓库的所有变更。这是因为远程分支现在是你本地分支的祖先，也就是说你的提交已经包含了远程分支的所有变化。\n实际上，我们使用\ngit pull --rebase git push 就可以更加方便地完成，这和上文的 rebase 方法完全相同。当然，如果使用 git pull，那么就相当于上文的 merge 方法了。\ngit rm –cached 在上传文件到 Git 上时，有时候会将本地的一些配置文件传到服务器上，这时候如果先删除本地，再同步服务器显然是不合理的。这时 Git 给我们提供了一种解决方法，可以直接删除服务器文件而不影响本地。命令如下：\ngit rm --cached filename git rm --cached -r directory 当我们提交并推送之后，服务器上的文件就不存在了。\n参考链接：\nlearngitbranching.js.org ","wordCount":"291","inLanguage":"en","datePublished":"2021-10-22T21:31:32+08:00","dateModified":"2021-10-22T21:31:32+08:00","author":{"@type":"Person","name":"James"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:1313/git-instruction-1/"},"publisher":{"@type":"Organization","name":"Laoluo's Blog","logo":{"@type":"ImageObject","url":"http://localhost:1313/icons/linux.png"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://localhost:1313/ accesskey=h title="Laoluo's Blog (Alt + H)">Laoluo's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li></ul></div></div><ul id=menu><li><a href=http://localhost:1313/about/ title=关于><span>关于</span></a></li><li><a href=http://localhost:1313/archives title=归档><span>归档</span></a></li><li><a href=http://localhost:1313/categories/ title=分类><span>分类</span></a></li><li><a href=http://localhost:1313/tags/ title=标签><span>标签</span></a></li><li><a href=http://localhost:1313/manual/ title=速查><span>速查</span></a></li><li><a href=http://localhost:1313/links/ title=链接><span>链接</span></a></li><li><a href=http://localhost:1313/search/ title=🔍><span>🔍</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Git 使用教程（上）</h1><div class=post-meta><span title='2021-10-22 21:31:32 +0800 CST'>October 22, 2021</span>&nbsp;·&nbsp;James</div></header><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e5%9f%ba%e6%9c%ac%e6%93%8d%e4%bd%9c aria-label=基本操作>基本操作</a><ul><li><a href=#commit aria-label=Commit>Commit</a></li><li><a href=#branch aria-label=Branch>Branch</a></li><li><a href=#merge aria-label=Merge>Merge</a></li><li><a href=#rebase aria-label=Rebase>Rebase</a></li><li><a href=#merge-%e5%92%8c-rebase-%e7%9a%84%e9%80%89%e6%8b%a9 aria-label="Merge 和 Rebase 的选择">Merge 和 Rebase 的选择</a></li></ul></li><li><a href=#%e8%bf%9c%e7%a8%8b%e4%bb%93%e5%ba%93 aria-label=远程仓库>远程仓库</a><ul><li><a href=#clone aria-label=Clone>Clone</a></li><li><a href=#fetch--pull aria-label="Fetch &amp;amp; Pull">Fetch & Pull</a></li><li><a href=#push aria-label=Push>Push</a></li></ul></li><li><a href=#git-rm---cached aria-label="git rm &amp;ndash;cached">git rm &ndash;cached</a></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><p>本文主要介绍了 Git 本地和远程的一些常用操作，包括 commit，branch，merge，rebase，fetch 和 push 等。</p><h2 id=基本操作>基本操作<a hidden class=anchor aria-hidden=true href=#基本操作>#</a></h2><h3 id=commit>Commit<a hidden class=anchor aria-hidden=true href=#commit>#</a></h3><p>Git 仓库中的提交记录保存的是你的目录下所有文件的快照。 Git 希望提交记录尽可能地轻量，因此在你每次进行提交时，它并不会盲目地复制整个目录。条件允许的情况下，它会将当前版本与仓库中的上一个版本进行对比，并把所有的差异打包到一起作为一个提交记录。 Git 还保存了提交的历史记录。</p><p>使用方法为</p><pre tabindex=0><code>git commit -m &#34;Some Message&#34;
</code></pre><h3 id=branch>Branch<a hidden class=anchor aria-hidden=true href=#branch>#</a></h3><p>Git 的分支也非常轻量。它们只是简单地指向某个提交纪录，仅此而已。因此即使创建再多的分支也不会造成储存或内存上的开销，并且按逻辑分解工作到不同的分支要比维护那些特别臃肿的分支简单多了。所以使用 Git 的一个原则就是<strong>早建分支，多用分支</strong>。</p><p>创建一个新的分支</p><pre tabindex=0><code>git branch newBranch
</code></pre><p>切换到该分支</p><pre tabindex=0><code>git checkout newBranch
</code></pre><p>上述两条命令可以由一种更简洁的方式实现</p><pre tabindex=0><code>git checkout -b newBranch
</code></pre><h3 id=merge>Merge<a hidden class=anchor aria-hidden=true href=#merge>#</a></h3><p>现在我们讨论如何将两个分支合并到一起。就是说我们新建一个分支，在其上开发某个新功能，开发完成后再合并回主线。完成该操作的第一种方法是 <code>git merge</code>。</p><p>例如，我们要将 bugFix 分支合并到 main 分支里，切换到 main 分支，执行</p><pre tabindex=0><code>git merge bugFix
</code></pre><p>这样 main 分支就包含了对代码库的所有修改。</p><center><img src=assets/merge.png width=50%></center><h3 id=rebase>Rebase<a hidden class=anchor aria-hidden=true href=#rebase>#</a></h3><p>合并分支的第二种方法是 <code>git rebase</code>。Rebase 实际上就是取出一系列的提交记录，“复制”它们，然后在另外一个地方逐个的放下去。Rebase 的优势就是可以创造更线性的提交历史。</p><p>我们想要把 bugFix 分支里的工作直接移到 main 分支上。移动以后会使得两个分支的功能看起来像是按顺序开发，但实际上它们是并行开发的。注意当前所在的分支是 bugFix。</p><pre tabindex=0><code>git rebase main
</code></pre><center><img src=assets/rebase.png width=50%></center><p>事实上，<code>git rebase</code> 可以添加两个参数，后面的参数默认为当前的分支。</p><pre tabindex=0><code>git rebase &lt;baseBranch&gt;  &lt;topicBranch&gt;
</code></pre><p>会将 topicBranch 变基到 baseBranch 上，也就是将 topicBranch 的代码“续”到了 baseBranch 后面。</p><p>上面的命令等价于</p><pre tabindex=0><code>git rebase main bugFix
</code></pre><p>这样，我们在进行 rebase 时就不需要频繁切换分支了。</p><p>我们只需要记住，rebase 时修改的是后面的分支，前面的分支不动就可以了。</p><h3 id=merge-和-rebase-的选择>Merge 和 Rebase 的选择<a hidden class=anchor aria-hidden=true href=#merge-和-rebase-的选择>#</a></h3><p>那么，我们在合并分支时应该什么时候使用 rebase，什么时候使用 merge 呢？</p><p>一个基本的原则是</p><p><strong>sub-branches rebase on master, master merges sub-branches.</strong></p><p>也就是在上例中，我们如果想要将 bugFix 里的工作合并到 main 中，应当采用</p><pre tabindex=0><code>git rebase main
git checkout main
git merge bugFix
</code></pre><h2 id=远程仓库>远程仓库<a hidden class=anchor aria-hidden=true href=#远程仓库>#</a></h2><h3 id=clone>Clone<a hidden class=anchor aria-hidden=true href=#clone>#</a></h3><p>远程仓库并不复杂, 在如今的云计算盛行的世界很容易把远程仓库想象成一个富有魔力的东西, 但实际上它们只是你的仓库在另个一台计算机上的拷贝。你可以通过因特网与这台计算机通信 —— 也就是增加或是获取提交记录。话虽如此, 远程仓库却有一系列强大的特性：</p><ul><li>首先也是最重要的的点, 远程仓库是一个强大的备份。本地仓库也有恢复文件到指定版本的能力, 但所有的信息都是保存在本地的。有了远程仓库以后，即使丢失了本地所有数据, 你仍可以通过远程仓库拿回你丢失的数据。</li><li>还有就是, 远程让代码社交化了! 既然你的项目被托管到别的地方了, 你的朋友可以更容易地为你的项目做贡献(或者拉取最新的变更)</li></ul><p><code>git clone</code> 命令的作用是在<strong>本地</strong>创建一个远程仓库的拷贝（比如从 github.com）。</p><p>当我们 clone 一个具有子模块的项目时，默认会包含该子模块目录，但其中还没有任何文件。我们必须运行两个命令：<code>git submodule init</code> 用来初始化本地配置文件，而 <code>git submodule update</code> 则从该项目中抓取所有数据并检出父项目中列出的合适的提交。</p><p>不过，还有一种更简单的方式，如果给 <code>git clone</code> 命令传递 <code>--recurse-submodules</code> 选项，它就会自动初始化并更新仓库中的每一个子模块， 包括可能存在的嵌套子模块。</p><h3 id=fetch--pull>Fetch & Pull<a hidden class=anchor aria-hidden=true href=#fetch--pull>#</a></h3><p><code>git fetch</code> 用于从远程仓库中获取数据。</p><p><code>git fetch</code> 完成了仅有的但是很重要的两步:</p><ul><li>从远程仓库下载本地仓库中缺失的提交记录</li><li>更新远程分支指针(如 <code>origin/main</code>)</li></ul><p><code>git fetch</code> 实际上将本地仓库中的远程分支更新成了远程仓库相应分支最新的状态。</p><center><img src=assets/fetch.png width=50%></center><p>而 <code>git fetch</code> 并不会改变你本地仓库的状态。它不会更新你的 <code>main</code> 分支，也不会修改你磁盘上的文件。</p><p>因此，我们需要执行通过以下命令来将这些变化更新到我们的工作当中。</p><pre tabindex=0><code>git cherry-pick origin/main
git rebase origin/main
git merge origin/main
</code></pre><p>实际上，由于先抓取更新再合并到本地分支这个流程很常用，因此 Git 提供了一个专门的命令来完成这两个操作。它就是我们要讲的 <code>git pull</code>。<code>git pull</code> 相当于 <code>git fetch</code> 和 <code>git merge</code> 两个操作。</p><center><img src=assets/pull.png width=50%></center><p>例如</p><pre tabindex=0><code>git fetch
git merge origin/main
</code></pre><p>和</p><pre tabindex=0><code>git pull
</code></pre><p>完全等价。</p><h3 id=push>Push<a hidden class=anchor aria-hidden=true href=#push>#</a></h3><p><code>git push</code> 负责将<strong>你的</strong>变更上传到指定的远程仓库，并在远程仓库上合并你的新提交记录。一旦 <code>git push</code> 完成, 你的朋友们就可以从这个远程仓库下载你分享的成果了！</p><p>但是，当历史偏离时 <code>git push</code> 会失败。比如你最新提交的 <code>C3</code> 基于远程分支中的 <code>C1</code>。而远程仓库中该分支已经更新到 <code>C2</code> 了，所以 Git 拒绝了你的推送请求。实际上它会强制你先合并远程最新的代码，然后才能分享你的工作。</p><center><img src=assets/push1.png width=50%></center><p>那该如何解决这个问题呢？很简单，你需要做的就是使你的工作基于最新的远程分支。有许多方法可以做到这一点，不过最直接的方法就是通过 rebase 调整你的工作。</p><p>我们可以在 push 之前做 rebase</p><pre tabindex=0><code>git fetch
git rebase origin/main
git push
</code></pre><center><img src=assets/push2.png width=50%></center><p>当然，也可以使用 merge。尽管 <code>git merge</code> 不会移动你的工作（它会创建新的合并提交），但是它会告诉 Git 你已经合并了远程仓库的所有变更。这是因为远程分支现在是你本地分支的祖先，也就是说你的提交已经包含了远程分支的所有变化。</p><center><img src=assets/push3.png width=50%></center><p>实际上，我们使用</p><pre tabindex=0><code>git pull --rebase
git push
</code></pre><p>就可以更加方便地完成，这和上文的 rebase 方法完全相同。当然，如果使用 <code>git pull</code>，那么就相当于上文的 merge 方法了。</p><h2 id=git-rm---cached>git rm &ndash;cached<a hidden class=anchor aria-hidden=true href=#git-rm---cached>#</a></h2><p>在上传文件到 Git 上时，有时候会将本地的一些配置文件传到服务器上，这时候如果先删除本地，再同步服务器显然是不合理的。这时 Git 给我们提供了一种解决方法，可以直接删除服务器文件而不影响本地。命令如下：</p><pre tabindex=0><code>git rm --cached filename
git rm --cached -r directory
</code></pre><p>当我们提交并推送之后，服务器上的文件就不存在了。</p><hr><p>参考链接：</p><ol><li><a href="https://learngitbranching.js.org/?locale=zh_CN">learngitbranching.js.org</a></li></ol></div><footer class=post-footer><ul class=post-tags><li><a href=http://localhost:1313/tags/git/>Git</a></li></ul><nav class=paginav><a class=prev href=http://localhost:1313/git-instruction-2/><span class=title>« Prev</span><br><span>Git 使用教程（下）</span>
</a><a class=next href=http://localhost:1313/software-set-proxy-mirror/><span class=title>Next »</span><br><span>常用软件设置代理及换源教程</span></a></nav></footer></article></main><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><footer class=footer><span>&copy; 2024 <a href=http://localhost:1313/>Laoluo's Blog</a></span>
<span>| Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span><br><a href=https://beian.miit.gov.cn/ target=_blank>黔ICP备2022001597号</a></footer><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>