<!doctype html><html lang=en dir=auto><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Git 使用教程（下） | Laoluo's Blog</title>
<meta name=keywords content="Git"><meta name=description content="本文主要介绍了 Git 的一些进阶操作，包括分离 HEAD，相对引用，cherry-pick，交互式 rebase 和 tag 等。"><meta name=author content="James"><link rel=canonical href=http://localhost:1313/git-instruction-2/><link crossorigin=anonymous href=/assets/css/stylesheet.d2540e28ae03a9ed42429ed74228412a18d4ea29c639e31e4f0b1512e252624f.css integrity="sha256-0lQOKK4Dqe1CQp7XQihBKhjU6inGOeMeTwsVEuJSYk8=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=http://localhost:1313/icons/linux.png><link rel=icon type=image/png sizes=16x16 href=http://localhost:1313/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=http://localhost:1313/favicon-32x32.png><link rel=apple-touch-icon href=http://localhost:1313/apple-touch-icon.png><link rel=mask-icon href=http://localhost:1313/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=http://localhost:1313/git-instruction-2/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/lxgw-wenkai-screen-webfont@1.7.0/style.min.css><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fontsource/cascadia-code@4.2.1/index.min.css><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><meta property="og:title" content="Git 使用教程（下）"><meta property="og:description" content="本文主要介绍了 Git 的一些进阶操作，包括分离 HEAD，相对引用，cherry-pick，交互式 rebase 和 tag 等。"><meta property="og:type" content="article"><meta property="og:url" content="http://localhost:1313/git-instruction-2/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-10-25T21:31:32+08:00"><meta property="article:modified_time" content="2021-10-25T21:31:32+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Git 使用教程（下）"><meta name=twitter:description content="本文主要介绍了 Git 的一些进阶操作，包括分离 HEAD，相对引用，cherry-pick，交互式 rebase 和 tag 等。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://localhost:1313/posts/"},{"@type":"ListItem","position":2,"name":"Git 使用教程（下）","item":"http://localhost:1313/git-instruction-2/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Git 使用教程（下）","name":"Git 使用教程（下）","description":"本文主要介绍了 Git 的一些进阶操作，包括分离 HEAD，相对引用，cherry-pick，交互式 rebase 和 tag 等。\n","keywords":["Git"],"articleBody":"本文主要介绍了 Git 的一些进阶操作，包括分离 HEAD，相对引用，cherry-pick，交互式 rebase 和 tag 等。\n分离 HEAD HEAD 是一个对当前检出记录的符号引用，也就是指向你正在其基础上进行工作的提交记录。HEAD 总是指向当前分支上最近一次提交记录。大多数修改提交树的 git 命令都是从改变 HEAD 的指向开始的。HEAD 通常情况下是指向分支名的（如 bugFix）。\n我们可以通过 checkout 一个分支\ngit checkout bugFix 来使 HEAD 指向该分支，\n也可以通过 chekcout 一个提交\ngit checkout C1 来使 HEAD 指向该提交。\n相对引用 通过指定提交记录哈希值的方式在 Git 中移动不太方便，所以 Git 引入了相对引用。使用相对引用的话，就可以从一个易于记忆的地方开始计算。相对引用有两个常用的用法：\n使用 ^ 向上移动 1 个提交记录 使用 ~ 向上移动 num 个提交记录 如：\ngit checkout HEAD^ 会向上移动 1 个提交记录。\n我们可以通过相对引用来移动分支。使用 -f 选项来让分支指向另一个提交。例如：\ngit branch -f main HEAD~3 会将 main 分支强制指向 HEAD 的第 3 级父提交。\n撤销变更 在 Git 中主要有两个方法来撤销变更，分别是 git reset 和 git revert。\ngit reset 通过把分支记录回退几个提交记录来实现撤销改动。你可以将这想象成“改写历史”。git reset 向上移动分支，原来指向的提交记录就跟从来没有提交过一样。实际上，在 reset 后，该提交所做的变更还在，但是处于未加入暂存区状态。如果我们要删除所做的更改，可以使用 --hard 选项。\n虽然在你的本地分支中使用 git reset 很方便，但是这种“改写历史”的方法对大家一起使用的远程分支是无效的哦！为了撤销更改并分享给别人，我们需要使用 git revert。\ngit revert 会在要撤销的提交后面新增一个提交，新提交的更改正是为了撤销上一个提交。因此 revert 之后我们就可以将更改推送到远程仓库与别人分享了。\nCherry-pick git cherry-pick 是整理提交记录的第一种方法。\ncherry-pick 可以将一些提交复制到当前所在的位置（HEAD）下面，如 side 分支上有 C2，C3，C4 三个提交，而我们只想将其中两个复制到 main 分支，就可以\ngit cherry-pick C2 C4 交互式 rebase 当你知道你所需要的提交记录（并且还知道这些提交记录的哈希值）时, 用 cherry-pick 再好不过了。但是如果你不清楚你想要的提交记录的哈希值呢? 那么这时我们可以利用交互式的 rebase——如果你想从一系列的提交记录中找到想要的记录, 这就是最好的方法了。\n交互式 rebase 指的是使用带参数 --interactive 的 rebase 命令, 简写为 -i。如果你在命令后增加了这个选项, Git 会打开一个 UI 界面并列出将要被复制到目标分支的备选提交记录，它还会显示每个提交记录的哈希值和提交说明，提交说明有助于你理解这个提交进行了哪些更改。\n交互式 rebase 的界面如下例所示：\npick f7f3f6d Change my name a bit pick 310154e Update README formatting and add blame pick a5f4a0d Add cat-file # Rebase 710f0f8..a5f4a0d onto 710f0f8 # # Commands: # p, pick = use commit # r, reword = use commit, but edit the commit message # e, edit = use commit, but stop for amending # s, squash = use commit, but meld into previous commit # f, fixup = like \"squash\", but discard this commit's log message # x, exec = run command (the rest of the line) using # b, break = stop here (continue rebase later with 'git rebase --continue') # d, drop = remove commit # l, label = label current HEAD with a name # t, reset = reset HEAD to a label # m, merge [-C | -c ] [# ] # . create a merge commit using the original merge commit's # . message (or the oneline, if no original merge commit was # . specified). Use -c to reword the commit message. # # These lines can be re-ordered; they are executed from top to bottom. # # If you remove a line here THAT COMMIT WILL BE LOST. # # However, if you remove everything, the rebase will be aborted. # # Note that empty commits are commented out 在交互式 rebase 的界面中，我们可以\n修改提交顺序。只需在编辑器中修改各行的顺序即可。 合并提交。我们可以将多个提交合并到一个提交中。方法是将想要的提交设置为 pick，而将想要合并的提交设置为 squash。保存后会出现一个新的编辑器窗口，在这里面可以修改提交信息。 拆分提交。我们也可以将一个提交拆分成多个提交。方法是将想要拆分的提交设置为 edit，保存退出后 git 会提示在该提交处停止了。这里可以用 git commit --amend 命令对提交信息重新编辑。而我们是要拆分提交，所以要先将提交 reset，然后重新提交。拆分完成后使用 git rebase --continue 结束 rebase。 删除提交。方法是在编辑器中直接删除那一行，保存退出后 git 会比较其前后两个提交的差异，如果有冲突需要手动解决冲突之后再 git rebase --continue。 Tag 我们知道，分支很容易被人为移动，并且当有新的提交时，它也会移动。分支很容易被改变，大部分分支还只是临时的，并且还一直在变。那么有没有什么可以永远指向某个提交记录的标识呢，比如软件发布新的大版本，或者是修正一些重要的 Bug 或是增加了某些新特性。 Git 的 Tag 正是这个用途。\n它们可以永久地将某个特定的提交命名为里程碑，然后就可以像分支一样引用了。更难得的是，它们并不会随着新的提交而移动。你也不能检出到某个标签上面进行修改提交，它就像是提交树上的一个锚点，标识了某个特定的位置。\ngit tag v1 C1 就将 C1 提交记录标记为了 1.0 版本。\nDescribe git describe的语法是\ngit describe 可以是任何能被 Git 识别成提交记录的引用，如果你没有指定的话， Git 会以你目前所检出的位置（HEAD）。\n它输出的结果是这样的：\n__g tag 表示的是离 ref 最近的标签，numCommits 是表示这个 ref 与 tag 相差有多少个提交记录，hash 表示的是你所给定的 ref 所表示的提交记录哈希值的前几位。当 ref 提交记录上有某个标签时，则只输出标签名称。\n例如，对于下面的提交树\ngit describe main 会输出：\nv1_2_gC2 git describe side 会输出：\nv2_1_gC4 参考链接：\nlearngitbranching.js.org ","wordCount":"460","inLanguage":"en","datePublished":"2021-10-25T21:31:32+08:00","dateModified":"2021-10-25T21:31:32+08:00","author":{"@type":"Person","name":"James"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:1313/git-instruction-2/"},"publisher":{"@type":"Organization","name":"Laoluo's Blog","logo":{"@type":"ImageObject","url":"http://localhost:1313/icons/linux.png"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://localhost:1313/ accesskey=h title="Laoluo's Blog (Alt + H)">Laoluo's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li></ul></div></div><ul id=menu><li><a href=http://localhost:1313/about/ title=关于><span>关于</span></a></li><li><a href=http://localhost:1313/archives title=归档><span>归档</span></a></li><li><a href=http://localhost:1313/categories/ title=分类><span>分类</span></a></li><li><a href=http://localhost:1313/tags/ title=标签><span>标签</span></a></li><li><a href=http://localhost:1313/manual/ title=速查><span>速查</span></a></li><li><a href=http://localhost:1313/links/ title=链接><span>链接</span></a></li><li><a href=http://localhost:1313/search/ title=🔍><span>🔍</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Git 使用教程（下）</h1><div class=post-meta><span title='2021-10-25 21:31:32 +0800 CST'>October 25, 2021</span>&nbsp;·&nbsp;James</div></header><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e5%88%86%e7%a6%bb-head aria-label="分离 HEAD">分离 HEAD</a></li><li><a href=#%e7%9b%b8%e5%af%b9%e5%bc%95%e7%94%a8 aria-label=相对引用>相对引用</a></li><li><a href=#%e6%92%a4%e9%94%80%e5%8f%98%e6%9b%b4 aria-label=撤销变更>撤销变更</a></li><li><a href=#cherry-pick aria-label=Cherry-pick>Cherry-pick</a></li><li><a href=#%e4%ba%a4%e4%ba%92%e5%bc%8f-rebase aria-label="交互式 rebase">交互式 rebase</a></li><li><a href=#tag aria-label=Tag>Tag</a></li><li><a href=#describe aria-label=Describe>Describe</a></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><p>本文主要介绍了 Git 的一些进阶操作，包括分离 HEAD，相对引用，cherry-pick，交互式 rebase 和 tag 等。</p><h2 id=分离-head>分离 HEAD<a hidden class=anchor aria-hidden=true href=#分离-head>#</a></h2><p>HEAD 是一个对当前检出记录的符号引用，也就是指向你正在其基础上进行工作的提交记录。HEAD 总是指向当前分支上最近一次提交记录。大多数修改提交树的 git 命令都是从改变 HEAD 的指向开始的。HEAD 通常情况下是指向分支名的（如 bugFix）。</p><p>我们可以通过 checkout 一个分支</p><pre tabindex=0><code>git checkout bugFix
</code></pre><p>来使 HEAD 指向该分支，</p><p>也可以通过 chekcout 一个提交</p><pre tabindex=0><code>git checkout C1
</code></pre><p>来使 HEAD 指向该提交。</p><h2 id=相对引用>相对引用<a hidden class=anchor aria-hidden=true href=#相对引用>#</a></h2><p>通过指定提交记录哈希值的方式在 Git 中移动不太方便，所以 Git 引入了相对引用。使用相对引用的话，就可以从一个易于记忆的地方开始计算。相对引用有两个常用的用法：</p><ul><li>使用 <code>^</code> 向上移动 1 个提交记录</li><li>使用 <code>~&lt;num></code> 向上移动 num 个提交记录</li></ul><p>如：</p><pre tabindex=0><code>git checkout HEAD^
</code></pre><p>会向上移动 1 个提交记录。</p><center><img src=assets/相对引用.png width=50%></center><p>我们可以通过相对引用来移动分支。使用 <code>-f</code> 选项来让分支指向另一个提交。例如：</p><pre tabindex=0><code>git branch -f main HEAD~3
</code></pre><p>会将 main 分支强制指向 HEAD 的第 3 级父提交。</p><h2 id=撤销变更>撤销变更<a hidden class=anchor aria-hidden=true href=#撤销变更>#</a></h2><p>在 Git 中主要有两个方法来撤销变更，分别是 <code>git reset</code> 和 <code>git revert</code>。</p><p><code>git reset</code> 通过把分支记录回退几个提交记录来实现撤销改动。你可以将这想象成“改写历史”。<code>git reset</code> 向上移动分支，原来指向的提交记录就跟从来没有提交过一样。实际上，在 reset 后，该提交所做的变更还在，但是处于未加入暂存区状态。如果我们要删除所做的更改，可以使用 <code>--hard</code> 选项。</p><center><img src=assets/reset.png width=50%></center><p>虽然在你的本地分支中使用 <code>git reset</code> 很方便，但是这种“改写历史”的方法对大家一起使用的远程分支是无效的哦！为了撤销更改并<strong>分享</strong>给别人，我们需要使用 <code>git revert</code>。</p><p><code>git revert</code> 会在要撤销的提交后面新增一个提交，新提交的更改正是为了撤销上一个提交。因此 revert 之后我们就可以将更改推送到远程仓库与别人分享了。</p><center><img src=assets/revert.png width=50%></center><h2 id=cherry-pick>Cherry-pick<a hidden class=anchor aria-hidden=true href=#cherry-pick>#</a></h2><p><code>git cherry-pick</code> 是整理提交记录的第一种方法。</p><p>cherry-pick 可以将一些提交复制到当前所在的位置（HEAD）下面，如 side 分支上有 C2，C3，C4 三个提交，而我们只想将其中两个复制到 main 分支，就可以</p><pre tabindex=0><code>git cherry-pick C2 C4
</code></pre><center><img src=assets/cherry-pick.png width=50%></center><h2 id=交互式-rebase>交互式 rebase<a hidden class=anchor aria-hidden=true href=#交互式-rebase>#</a></h2><p>当你知道你所需要的提交记录（<strong>并且</strong>还知道这些提交记录的哈希值）时, 用 cherry-pick 再好不过了。但是如果你不清楚你想要的提交记录的哈希值呢? 那么这时我们可以利用交互式的 rebase——如果你想从一系列的提交记录中找到想要的记录, 这就是最好的方法了。</p><p>交互式 rebase 指的是使用带参数 <code>--interactive</code> 的 rebase 命令, 简写为 <code>-i</code>。如果你在命令后增加了这个选项, Git 会打开一个 UI 界面并列出将要被复制到目标分支的备选提交记录，它还会显示每个提交记录的哈希值和提交说明，提交说明有助于你理解这个提交进行了哪些更改。</p><p>交互式 rebase 的界面如下例所示：</p><pre tabindex=0><code>pick f7f3f6d Change my name a bit
pick 310154e Update README formatting and add blame
pick a5f4a0d Add cat-file

# Rebase 710f0f8..a5f4a0d onto 710f0f8
#
# Commands:
# p, pick &lt;commit&gt; = use commit
# r, reword &lt;commit&gt; = use commit, but edit the commit message
# e, edit &lt;commit&gt; = use commit, but stop for amending
# s, squash &lt;commit&gt; = use commit, but meld into previous commit
# f, fixup &lt;commit&gt; = like &#34;squash&#34;, but discard this commit&#39;s log message
# x, exec &lt;command&gt; = run command (the rest of the line) using
# b, break = stop here (continue rebase later with &#39;git rebase --continue&#39;)
# d, drop &lt;commit&gt; = remove commit
# l, label &lt;label&gt; = label current HEAD with a name
# t, reset &lt;label&gt; = reset HEAD to a label
# m, merge [-C &lt;commit&gt; | -c &lt;commit&gt;] &lt;label&gt; [# &lt;oneline&gt;]
# .       create a merge commit using the original merge commit&#39;s
# .       message (or the oneline, if no original merge commit was
# .       specified). Use -c &lt;commit&gt; to reword the commit message.
#
# These lines can be re-ordered; they are executed from top to bottom.
#
# If you remove a line here THAT COMMIT WILL BE LOST.
#
# However, if you remove everything, the rebase will be aborted.
#
# Note that empty commits are commented out
</code></pre><p>在交互式 rebase 的界面中，我们可以</p><ul><li>修改提交顺序。只需在编辑器中修改各行的顺序即可。</li><li>合并提交。我们可以将多个提交合并到一个提交中。方法是将想要的提交设置为 <code>pick</code>，而将想要合并的提交设置为 <code>squash</code>。保存后会出现一个新的编辑器窗口，在这里面可以修改提交信息。</li><li>拆分提交。我们也可以将一个提交拆分成多个提交。方法是将想要拆分的提交设置为 <code>edit</code>，保存退出后 git 会提示在该提交处停止了。这里可以用 <code>git commit --amend</code> 命令对提交信息重新编辑。而我们是要拆分提交，所以要先将提交 reset，然后重新提交。拆分完成后使用 <code>git rebase --continue</code> 结束 rebase。</li><li>删除提交。方法是在编辑器中直接删除那一行，保存退出后 git 会比较其前后两个提交的差异，如果有冲突需要手动解决冲突之后再 <code>git rebase --continue</code>。</li></ul><h2 id=tag>Tag<a hidden class=anchor aria-hidden=true href=#tag>#</a></h2><p>我们知道，分支很容易被人为移动，并且当有新的提交时，它也会移动。分支很容易被改变，大部分分支还只是临时的，并且还一直在变。那么有没有什么可以<em>永远</em>指向某个提交记录的标识呢，比如软件发布新的大版本，或者是修正一些重要的 Bug 或是增加了某些新特性。 Git 的 Tag 正是这个用途。</p><p>它们可以永久地将某个特定的提交命名为里程碑，然后就可以像分支一样引用了。更难得的是，它们并不会随着新的提交而移动。你也不能检出到某个标签上面进行修改提交，它就像是提交树上的一个锚点，标识了某个特定的位置。</p><pre tabindex=0><code>git tag v1 C1
</code></pre><p>就将 C1 提交记录标记为了 1.0 版本。</p><center><img src=assets/tag.png width=50%></center><h2 id=describe>Describe<a hidden class=anchor aria-hidden=true href=#describe>#</a></h2><p><code>git describe</code>的语法是</p><pre tabindex=0><code>git describe &lt;ref&gt;
</code></pre><p><code>&lt;ref></code> 可以是任何能被 Git 识别成提交记录的引用，如果你没有指定的话， Git 会以你目前所检出的位置（<code>HEAD</code>）。</p><p>它输出的结果是这样的：</p><pre tabindex=0><code>&lt;tag&gt;_&lt;numCommits&gt;_g&lt;hash&gt;
</code></pre><p><code>tag</code> 表示的是离 <code>ref</code> 最近的标签，<code>numCommits</code> 是表示这个 <code>ref</code> 与 <code>tag</code> 相差有多少个提交记录，<code>hash</code> 表示的是你所给定的 <code>ref</code> 所表示的提交记录哈希值的前几位。当 <code>ref</code> 提交记录上有某个标签时，则只输出标签名称。</p><p>例如，对于下面的提交树</p><center><img src=assets/describe.png width=50%></center><p><code>git describe main</code> 会输出：</p><pre tabindex=0><code>v1_2_gC2
</code></pre><p><code>git describe side</code> 会输出：</p><pre tabindex=0><code>v2_1_gC4
</code></pre><hr><p>参考链接：</p><ol><li><a href="https://learngitbranching.js.org/?locale=zh_CN">learngitbranching.js.org</a></li></ol></div><footer class=post-footer><ul class=post-tags><li><a href=http://localhost:1313/tags/git/>Git</a></li></ul><nav class=paginav><a class=prev href=http://localhost:1313/wsl2-docker-instruction/><span class=title>« Prev</span><br><span>Windows 11 系统启用 WSL 2 并安装 Docker</span>
</a><a class=next href=http://localhost:1313/git-instruction-1/><span class=title>Next »</span><br><span>Git 使用教程（上）</span></a></nav></footer></article></main><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><footer class=footer><span>&copy; 2024 <a href=http://localhost:1313/>Laoluo's Blog</a></span>
<span>| Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span><br><a href=https://beian.miit.gov.cn/ target=_blank>黔ICP备2022001597号</a></footer><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>